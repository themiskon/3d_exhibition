<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>3D Exhibition</title>
  <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
  <style>
    body { margin:0; overflow:hidden; }
    #controls-popup {
      position: fixed; top:0; left:0; width:100%; height:100%;
      background: rgba(0,0,0,0.85); color:white;
      display:flex; flex-direction:column;
      justify-content:center; align-items:center;
      z-index:9999; text-align:center;
    }
    #controls-popup button {
      padding:12px 24px; margin-top:20px; font-size:16px;
      cursor:pointer; border:none; border-radius:6px;
      background:#4CAF50; color:white;
    }
  </style>
</head>
<body>

<div id="controls-popup">
  <h2>Welcome to the Exhibition</h2>
  <p>Use <b>WASD</b> to move</p>
  <p>Use <b>Mouse</b> to look around</p>
  <p>Press <b>Q</b> to go up, <b>E</b> to go down</p>
  <button id="start-btn">Start Exhibition</button>
</div>

<a-scene background="color:#001a33" id="scene">

  <!-- Camera rig -->
  <a-entity id="rig" position="0 1.6 5" 
            wasd-controls="acceleration: 20; fly: false; enabled: true"
            look-controls="pointerLockEnabled: false; touchEnabled: true">
    <a-entity camera></a-entity>
  </a-entity>

  <!-- Floor -->
  <a-plane rotation="-90 0 0" width="50" height="50" color="#033"></a-plane>

  <!-- Lights -->
  <a-entity light="type: directional; intensity:0.8" position="10 20 10"></a-entity>
  <a-entity light="type: ambient; intensity:0.5"></a-entity>

  <!-- Containers -->
  <a-entity id="posters"></a-entity>
  <a-entity id="bathy"></a-entity>
  <a-entity id="quakes"></a-entity>

</a-scene>

<script>
document.addEventListener('DOMContentLoaded', () => {
  const startBtn = document.getElementById('start-btn');
  const rig = document.getElementById('rig');
  const sceneEl = document.getElementById('scene');
  let bathyData = null;
  let startPressed = false;
  let bathyMeshAdded = false; // prevent duplicates
  let quakesAdded = false;    // prevent duplicates

  // Utility: ensure scene/THREE available
  function whenSceneReady(cb) {
    if (sceneEl.hasLoaded) cb();
    else sceneEl.addEventListener('loaded', cb, { once: true });
  }

  // Utility: clear a container's THREE children
  function clearObject3DChildren(container) {
    if (!container || !container.object3D) return;
    const children = [...container.object3D.children];
    children.forEach(ch => container.object3D.remove(ch));
  }

  // --- Start Exhibition ---
  startBtn.addEventListener('click', () => {
    document.getElementById('controls-popup').style.display = 'none';
    startPressed = true;
    if (bathyData) whenSceneReady(() => addBathyMesh(bathyData));
  });

  // --- Height adjustment Q/E ---
  document.addEventListener("keydown", e => {
    if (!rig || !rig.object3D) return;
    const y = rig.object3D.position.y;
    if (e.code === "KeyQ") rig.object3D.position.y = y + 0.5;
    if (e.code === "KeyE") rig.object3D.position.y = Math.max(1, y - 0.5);
  });

  // --- Load posters (preserve order after all load) ---
  fetch('posters.json')
    .then(res => res.json())
    .then(srcs => {
      const container = document.querySelector('#posters');
      const spacing = 4;

      // Preload all images, then place in original order
      const loaders = srcs.map(src => new Promise(resolve => {
        const img = new Image();
        img.onload = () => resolve({ src, width: img.naturalWidth, height: img.naturalHeight });
        img.onerror = () => resolve({ src, width: 1000, height: 1000 }); // fallback aspect
        img.src = src;
      }));

      return Promise.all(loaders).then(images => {
        images.forEach((meta, index) => {
          const aspect = meta.height / meta.width;
          const width = 2;
          const height = width * aspect;

          const poster = document.createElement('a-plane');
          poster.setAttribute('src', meta.src);
          poster.setAttribute('width', width);
          poster.setAttribute('height', height);
          poster.setAttribute('material','side: double; shader: flat');

          const x = -((images.length - 1) / 2) * spacing + index * spacing;
          const yPos = height / 2 + 0.5;
          const z = -5;
          poster.setAttribute('position', `${x} ${yPos} ${z}`);
          container.appendChild(poster);
        });
      });
    })
    .catch(err => console.error('Posters error:', err));

  // --- Load bathymetry ---
  fetch('data/baltic_bathy.json')
    .then(res => res.json())
    .then(data => {
      bathyData = data;
      if (startPressed) whenSceneReady(() => addBathyMesh(bathyData));
    })
    .catch(err => console.error('Bathymetry error:', err));

  function addBathyMesh(data){
    if (bathyMeshAdded) return;
    bathyMeshAdded = true;

    const container = document.querySelector('#bathy');
    if (!container || !container.object3D) return;

    clearObject3DChildren(container);

    const scale = 3;
    const landPoints = data.land.map(p => ({...p, type:'land'}));
    const waterPoints = data.water.map(p => ({...p, type:'water'}));
    const allPoints = [...landPoints, ...waterPoints];

    const geometry = new THREE.BufferGeometry();
    const vertices = new Float32Array(allPoints.length * 3);
    const colors = new Float32Array(allPoints.length * 3);

    for (let i = 0; i < allPoints.length; i++) {
      const p = allPoints[i];
      const x = (p.x - 25) * scale;
      const z = (p.y - 36) * scale;
      const y = p.z / 50 + 3; // slightly above floor

      const vi = i * 3;
      vertices[vi] = x;
      vertices[vi + 1] = y;
      vertices[vi + 2] = -z;

      if (p.type === 'land') {
        colors[vi] = 0.133; colors[vi + 1] = 0.545; colors[vi + 2] = 0.133; // green
      } else {
        colors[vi] = 0.118; colors[vi + 1] = 0.565; colors[vi + 2] = 1.0;   // blue
      }
    }

    geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
    geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

    // Use a reasonable fixed pixel size with attenuation for perspective cameras
    // Per THREE docs: size is pixels if sizeAttenuation=false, world-units if true (default true) [web:5]
    const material = new THREE.PointsMaterial({
      vertexColors: true,
      size: 0.03,
      sizeAttenuation: true,
      transparent: true,
      opacity: 0.6
    });

    const points = new THREE.Points(geometry, material);

    // Position next to posters
    const posters = document.querySelectorAll('#posters a-plane');
    const maxX = posters.length > 0 ? Math.max(...Array.from(posters).map(p => p.object3D.position.x)) : 0;
    points.position.set(maxX + 4, 0, -5);

    container.object3D.add(points);

    // --- Load quake points below bathymetry ---
    loadQuakes(maxX + 4);
  }

  // --- Load quakes ---
  function loadQuakes(xOffset){
    if (quakesAdded) return;
    fetch('data/quakes.json')
      .then(res => res.json())
      .then(data => {
        if (quakesAdded) return;
        quakesAdded = true;

        const container = document.querySelector('#quakes');
        if (!container || !container.object3D) return;

        clearObject3DChildren(container);

        const scale = 3;
        const yOffset = 2.8; // slightly below bathymetry plane

        data.sort((a,b)=> new Date(a.time || a.datetime) - new Date(b.time || b.datetime));

        const geometry = new THREE.BufferGeometry();
        const vertices = new Float32Array(data.length * 3);
        const colors = new Float32Array(data.length * 3);

        for (let i = 0; i < data.length; i++) {
          const event = data[i];
          const x = (event.x - 25) * scale;
          const z = (event.y - 36) * scale;
          const y = event.z / 50 + yOffset;

          const vi = i * 3;
          vertices[vi] = x;
          vertices[vi + 1] = y;
          vertices[vi + 2] = -z;

          colors[vi] = 1; colors[vi + 1] = 0; colors[vi + 2] = 0; // red
        }

        geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices,3));
        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors,3));

        // Use a visible fixed size; no per-point size attribute without custom shader
        const material = new THREE.PointsMaterial({
          vertexColors: true,
          size: 0.06,
          sizeAttenuation: true,
          transparent: true,
          opacity: 0.95
        });

        const points = new THREE.Points(geometry, material);
        points.position.set(xOffset, 0, -5);
        container.object3D.add(points);

        // Simple reveal animation by fading opacity up instead of per-vertex sizes
        // Per-vertex size would require a custom shader; PointsMaterial ignores custom "size" attribute [web:5][web:11]
        let shown = 0;
        const step = Math.max(1, Math.floor(data.length / 50));
        const interval = setInterval(() => {
          shown += step;
          const alpha = Math.min(1, shown / data.length);
          material.opacity = 0.3 + 0.65 * alpha;
          material.needsUpdate = true;
          if (shown >= data.length) clearInterval(interval);
        }, 100);
      })
      .catch(err => console.error('Quakes error:',err));
  }

  // Wait for scene readiness for any THREE operations
  whenSceneReady(() => {
    // no-op placeholder; ensures A-Frame/THREE is initialized before dynamic additions [web:15][web:6]
  });

});
</script>

<!-- Mobile movement buttons -->
<div id="mobile-controls" style="
  position: fixed;
  bottom: 20px;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  gap: 10px;
  z-index: 9999;
  pointer-events: auto;
">
  <button data-move="forward" style="padding:10px 15px;">▲</button>
  <button data-move="backward" style="padding:10px 15px;">▼</button>
  <button data-move="left" style="padding:10px 15px;">◀</button>
  <button data-move="right" style="padding:10px 15px;">▶</button>
  <button data-move="up" style="padding:10px 15px;">⬆</button>
  <button data-move="down" style="padding:10px 15px;">⬇</button>
</div>

<script>
  (function(){
    const rig = document.getElementById('rig');
    const sceneEl = document.getElementById('scene');
    if(!rig) return;

    const moveSpeed = 0.2;
    const activeKeys = {};

    document.querySelectorAll('#mobile-controls button').forEach(btn => {
      // Support both touch and mouse for robustness
      ['touchstart','mousedown'].forEach(ev => {
        btn.addEventListener(ev, e=>{
          e.preventDefault();
          activeKeys[btn.dataset.move] = true;
        });
      });
      ['touchend','mouseup','mouseleave'].forEach(ev => {
        btn.addEventListener(ev, e=>{
          e.preventDefault();
          activeKeys[btn.dataset.move] = false;
        });
      });
    });

    function whenSceneReady(cb) {
      if (sceneEl.hasLoaded) cb();
      else sceneEl.addEventListener('loaded', cb, { once: true });
    }

    whenSceneReady(() => {
      function moveLoop(){
        if(!rig || !rig.object3D) return;

        // In three.js, camera looks down -Z; getWorldDirection returns the forward direction (-Z) by default [web:10]
        const forward = new THREE.Vector3();
        rig.object3D.getWorldDirection(forward); // forward ≈ (0,0,-1) in world space [web:10]

        // Compute right vector as cross of forward with world up
        const up = new THREE.Vector3(0,1,0);
        const right = new THREE.Vector3().crossVectors(forward, up).normalize();

        // Forward/backward (move along forward)
        if(activeKeys.forward) rig.object3D.position.addScaledVector(forward, moveSpeed);
        if(activeKeys.backward) rig.object3D.position.addScaledVector(forward, -moveSpeed);

        // Left/right (move along right)
        if(activeKeys.left) rig.object3D.position.addScaledVector(right, -moveSpeed);
        if(activeKeys.right) rig.object3D.position.addScaledVector(right, moveSpeed);

        // Up/down
        if(activeKeys.up) rig.object3D.position.y += moveSpeed;
        if(activeKeys.down) rig.object3D.position.y -= moveSpeed;

        requestAnimationFrame(moveLoop);
      }

      moveLoop();
    });
  })();
</script>

<style>
  /* Hide mobile controls on desktop */
  @media (min-width: 768px) {
    #mobile-controls { display: none !important; }
  }
</style>

</body>
</html>
