<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>3D Exhibition</title>
  <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
  <style>
    body { margin:0; overflow:hidden; }
    #controls-popup {
      position: fixed; top:0; left:0; width:100%; height:100%;
      background: rgba(0,0,0,0.85); color:white;
      display:flex; flex-direction:column;
      justify-content:center; align-items:center;
      z-index:9999; text-align:center;
    }
    #controls-popup button {
      padding:12px 24px; margin-top:20px; font-size:16px;
      cursor:pointer; border:none; border-radius:6px;
      background:#4CAF50; color:white;
    }
  </style>
</head>
<body>

<div id="controls-popup">
  <h2>Welcome to the Exhibition</h2>
  <p>Use <b>WASD</b> to move</p>
  <p>Use <b>Mouse</b> to look around</p>
  <p>Press <b>Q</b> to go up, <b>E</b> to go down</p>
  <button id="start-btn">Start Exhibition</button>
</div>

<a-scene background="color:#001a33">

  <!-- Camera rig -->
  <a-entity id="rig" position="0 1.6 5" 
          wasd-controls="acceleration: 20; fly: false; enabled: true"
          look-controls="pointerLockEnabled: false; touchEnabled: true">
  <a-entity camera></a-entity>
  </a-entity>

  <!-- Floor -->
  <a-plane rotation="-90 0 0" width="50" height="50" color="#033"></a-plane>

  <!-- Lights -->
  <a-entity light="type: directional; intensity:0.8" position="10 20 10"></a-entity>
  <a-entity light="type: ambient; intensity:0.5"></a-entity>

  <!-- Containers -->
  <a-entity id="posters"></a-entity>
  <a-entity id="bathy"></a-entity>
  <a-entity id="quakes"></a-entity>

</a-scene>

<script>
document.addEventListener('DOMContentLoaded', () => {
  const startBtn = document.getElementById('start-btn');
  const rig = document.getElementById('rig');
  let bathyData = null;
  let startPressed = false;

  // --- Start Exhibition ---
  startBtn.addEventListener('click', () => {
    document.getElementById('controls-popup').style.display = 'none';
    startPressed = true;
    if(bathyData) addBathyMesh(bathyData);
  });

  // --- Height adjustment Q/E ---
  document.addEventListener("keydown", e => {
    const y = rig.object3D.position.y;
    if(e.code === "KeyQ") rig.object3D.position.y = y + 0.5;
    if(e.code === "KeyE") rig.object3D.position.y = Math.max(1, y - 0.5);
  });

  // --- Load posters ---
  fetch('posters.json')
    .then(res => res.json())
    .then(posters => {
      const container = document.querySelector('#posters');
      const spacing = 4;
      posters.forEach((src,index)=>{
        const img = new Image();
        img.src = src;
        img.onload = () => {
          const aspect = img.naturalHeight / img.naturalWidth;
          const width = 2;
          const height = width * aspect;

          const poster = document.createElement('a-plane');
          poster.setAttribute('src', src);
          poster.setAttribute('width', width);
          poster.setAttribute('height', height);
          poster.setAttribute('material','side: double; shader: flat');

          const x = -((posters.length-1)/2)*spacing + index*spacing;
          const yPos = height/2 + 0.5;
          const z = -5;
          poster.setAttribute('position',`${x} ${yPos} ${z}`);
          container.appendChild(poster);
        };
      });
    })
    .catch(err => console.error('Posters error:', err));

  // --- Load bathymetry ---
  fetch('data/baltic_bathy.json')
    .then(res => res.json())
    .then(data => {
      bathyData = data;
      if(startPressed) addBathyMesh(bathyData);
    })
    .catch(err => console.error('Bathymetry error:', err));

  function addBathyMesh(data){
    const container = document.querySelector('#bathy');
    const scale = 3;
    const landPoints = data.land.map(p=>({...p,type:'land'}));
    const waterPoints = data.water.map(p=>({...p,type:'water'}));
    const allPoints = [...landPoints, ...waterPoints];

    const geometry = new THREE.BufferGeometry();
    const vertices = [];
    const colors = [];

    allPoints.forEach(p=>{
      const x = (p.x - 25) * scale;
      const z = (p.y - 36) * scale;
      const y = p.z/50 + 3; // slightly above floor

      vertices.push(x,y,-z);

      if(p.type==='land') colors.push(0.133,0.545,0.133); // green
      else colors.push(0.118,0.565,1); // blue
    });

    geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices,3));
    geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors,3));

    const material = new THREE.PointsMaterial({vertexColors:true, size:0.03, transparent:true, opacity:0.3});
    const points = new THREE.Points(geometry, material);

    // Position next to posters
    const posters = document.querySelectorAll('#posters a-plane');
    const maxX = posters.length > 0 ? Math.max(...Array.from(posters).map(p=>p.object3D.position.x)) : 0;
    points.position.set(maxX + 4, 0, -5);

    container.object3D.add(points);

    // --- Load quake points below bathymetry ---
    loadQuakes(maxX + 4);
  }

  // --- Load quakes ---
  function loadQuakes(xOffset){
    fetch('data/quakes.json')
      .then(res => res.json())
      .then(data=>{
        const container = document.querySelector('#quakes');
        const scale = 3;
        const yOffset = 2.8; // slightly below bathymetry plane

        data.sort((a,b)=> new Date(a.time || a.datetime) - new Date(b.time || b.datetime));

        const geometry = new THREE.BufferGeometry();
        const vertices = [];
        const colors = [];
        const sizes = [];

        data.forEach(event=>{
          const x = (event.x - 25) * scale;
          const z = (event.y - 36) * scale;
          const y = event.z/50 + yOffset;

          vertices.push(x,y,-z);
          colors.push(1,0,0);
          sizes.push(0); // start invisible
        });

        geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices,3));
        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors,3));
        geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes,1));

        const material = new THREE.PointsMaterial({
          vertexColors:true,
          size:0.06,
          transparent:true,
          opacity:0.9
        });

        const points = new THREE.Points(geometry, material);
        points.position.set(xOffset,0,-5);
        container.object3D.add(points);

        // Animate quakes
        animateQuakes(geometry, sizes);
      })
      .catch(err => console.error('Quakes error:',err));
  }

  function animateQuakes(geometry,sizes){
    const total = sizes.count;
    let count = 0;
    const interval = setInterval(()=>{
      if(count>=total){
        clearInterval(interval);
        return;
      }
      sizes.setX(count, 0.06 + Math.random()*0.02);
      sizes.needsUpdate = true;
      count++;
    },100);
  }

});
</script>


<!-- Mobile movement buttons -->
<div id="mobile-controls" style="
  position: fixed;
  bottom: 20px;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  gap: 10px;
  z-index: 9999;
  pointer-events: auto;
">
  <button data-move="forward" style="padding:10px 15px;">▲</button>
  <button data-move="backward" style="padding:10px 15px;">▼</button>
  <button data-move="left" style="padding:10px 15px;">◀</button>
  <button data-move="right" style="padding:10px 15px;">▶</button>
  <button data-move="up">⬆</button>
  <button data-move="down">⬇</button>
</div>

<script>
  (function(){
    const rig = document.getElementById('rig');
    if(!rig) return;

    const moveSpeed = 0.2;
    const activeKeys = {};

    document.querySelectorAll('#mobile-controls button').forEach(btn => {
      btn.addEventListener('touchstart', e=>{
        e.preventDefault();
        activeKeys[btn.dataset.move] = true;
      });
      btn.addEventListener('touchend', e=>{
        e.preventDefault();
        activeKeys[btn.dataset.move] = false;
      });
    });

    function moveLoop(){
      if(!rig) return;
      const direction = new THREE.Vector3();
      rig.object3D.getWorldDirection(direction); // camera forward

      const right = new THREE.Vector3();
      right.crossVectors(rig.object3D.up, direction).normalize();

      // Forward/backward
      if(activeKeys.forward) rig.object3D.position.addScaledVector(direction, -moveSpeed);
      if(activeKeys.backward) rig.object3D.position.addScaledVector(direction, moveSpeed);

      // Left/right
      if(activeKeys.left) rig.object3D.position.addScaledVector(right, moveSpeed); // flipped
      if(activeKeys.right) rig.object3D.position.addScaledVector(right, -moveSpeed);

      // Up/down
      if(activeKeys.up) rig.object3D.position.y += moveSpeed;
      if(activeKeys.down) rig.object3D.position.y -= moveSpeed;

      requestAnimationFrame(moveLoop);
    }

    moveLoop();
  })();
</script>


<style>
  /* Hide mobile controls on desktop */
  @media (min-width: 768px) {
    #mobile-controls { display: none !important; }
  }
</style>

</body>
</html>
